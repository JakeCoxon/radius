import compiler for generator, concat, assert
import range for Range


fn foop(x: int):

  foo :: |yield|
    for i in Range(0, x):
      yield(i)

  bar :: |yield|
    for i in Range(1, 9):
      yield(i * i)

  bamp :: |yield|
    for i in Range(1, 9):
      yield(i * i * i)

  baz :: |yield|
    f := 1
    while true:
      yield(f)
      f *= 2

  consume :: |yield|
    while true:
      val := yield()
      print(val)

    
  consume2 :: |yield|
    val := yield()
    print("val 1", val)
    val = yield()
    print("val 2", val)
    val = yield()
    print("val 3", val)
    val = yield()
    print("val 4", val)

  
  numbers := [40, 20, 10, 32, 12, 3124]

  count := (fold(0) + numbers[:] * bamp[:] ...)
  print(count)
  assert(count == 678802)

  foos := [0, 0, 0, 0]
  foos[:] = numbers[:] * bamp[:] + 2 ...

  count2 := (fold(0) + foos[:] ...)
  print(count2)
  assert(count2 == 2526)

  count3 := (fold(0) + foo[:] ...)
  print(count3)
  assert(count3 == 45)

  x1 := @all(numbers[:] > 9)
  assert(x1 == true)
  print(x1)

  x2 := @all(numbers[:] < 1000)
  assert(x2 == false)
  print(x2)

  y1 := @any(numbers[:] == 20)
  assert(y1 == true)
  print(y1)

  y2 := @any(numbers[:] == 1000)
  assert(y2 == false)
  print(y2)

  z1 := @sum(numbers[1:])
  assert(z1 == 3198)
  print(z1)

  w1 := @sum(bar[:])
  print(w1)
  assert(w1 == 204)

  # Ideas

  # @[numbers[:] ..., numbers[1:] ...]
  # @max(numbers[:] + foo[:] in numbers[:])
  # @max(numbers[:] where numbers[:] + foo[:])
  # @max(select(numbers[:]).size)

  #x := sum(x for x in lst1 if lst1[:] > 2)
  #x := max(lst1 if lst1[:] > 2) orelse 0



fn main():
  foop(10)