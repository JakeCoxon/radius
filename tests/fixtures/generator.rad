import compiler for generator, assert
import range for Range

const to_iterator = |thing|
  {|yield|
    for v in thing:
      yield(v)
  }

# TODO: Can this work?
# Where the compiler automatically generates the interleave
# control flow and disallows using yield_outer twice otherwise
# concat2 :: |iterator_a, iterator_b|
#   {|yield_outer: iter|
#     while true:
#       iterator_a({|consume| 
# let         elem = consume()
#         yield_outer(elem)
#       })
#       iterator_b({|consume| 
# let         elem = consume()
#         yield_outer(elem)
#       })
#   }
# or
# concat2 :: |iterator_a, iterator_b|
#   {|yield_outer: yielder|
#     while true:
# let       elem_a = consume(iterator_a)
#       yield_outer(elem_a)
# let       elem_b = consume(iterator_b)
#       yield_outer(elem_b)
#   }
# a
# concat2 :: {|iterator_a: iter, iterator_b: iter| -> |outer: yielder|
#   while true:
# let     elem_a = iterator_a()
#     outer(elem_a)
# let     elem_b = iterator_b()
#     outer(elem_b)
# }
# a




const concat2 = |iterator_a, iterator_b|
  {|yield_outer|
    generator({|consume| 
      while true:
        let elem = consume()
        yield_outer(elem)
    }, {|yield|
      iterator_a(yield)
      iterator_b(yield)
    })
  }


# zip2 :: {|iterator_a: Iterator, iterator_b: Iterator|
#   {|yield_outer|
#     while true:
# let       elem_a = consume(iterator_a)
# let       elem_b = consume(iterator_b)
#       yield_outer((elem_a, elem_b))
#   }
# }

const zip2 = |iterator_a, iterator_b|
  {|yield_outer|
    generator({|consume_b|
      generator({|consume_a| 
        while true:
          let elem_a = consume_a()
          let elem_b = consume_b()
          yield_outer((elem_a, elem_b))
      }, iterator_a)
    }, iterator_b)
  }
  

const interpose = |iterator, value|
  {|yield_outer|
    generator({|consume| 
      let elem = consume()
      yield_outer(elem)
      while true:
        let elem2 = consume()
        yield_outer(value)
        yield_outer(elem2)
    }, iterator)
  }
  
const interleave = |iterator_a, iterator_b|
  {|yield_outer|
    generator({|consume_a| 
      generator({|consume_b| 
        while true:
          let elem_a = consume_a()
          yield_outer(elem_a)
          let elem_b = consume_b()
          yield_outer(elem_b)
      }, iterator_b)
    }, iterator_a)
  }

const interleave_infinite = |iterator_a, iterator_b|
  {|yield_outer|

    # Track which one is complete
    let complete_a = false
    let complete_b = false

    generator({|consume_a| 
      generator({|consume_b| 
        while !complete_a or !complete_b:
          let elem_a = consume_a()
          if !complete_a:
            yield_outer(elem_a) # TODO: yield is repeated!
          let elem_b = consume_b()
          if !complete_b:
            yield_outer(elem_b) # TODO: yield is repeated!
      }, {|yield_c|
        for elem in iterator_b:
          yield_c(elem)
        complete_b = true
        while true:
          yield_c(0)
      })
    }, {|yield_d|
      for elem in iterator_a:
        yield_d(elem)
      complete_a = true
      while true:
        yield_d(0)
    })
  }

# interleave_infinite :: |iterator_a, iterator_b| -> |yield_outer|

#   generator!({|yield_a| 
#     generator!({|yield_b| 
#       while true:
#         let complete_a, elem_a = yield_a()
#         if !complete_a: yield_outer(elem_a)

#         let complete_b, elem_b = yield_b()
#         if !complete_b: yield_outer(elem_b)

#         if !complete_a and !complete_b: break
#     }, {|yield_c|
#       for elem in iterator_b: yield_c(false, elem)
#       while true: yield_c(true, 0)
#     })()
#   }, {|yield_d|
#     for elem in iterator_a: yield_d((false, elem))
#     while true: yield_d((true, 0))
#   })()

const foo = |yield|
  for i in Range(0, 10):
    yield(i)

const bar = |yield|
  for i in Range(1, 9):
    yield(i * i)

const bamp = |yield|
  for i in Range(1, 9):
    yield(i * i * i)

const baz = |yield|
  let f = 1
  while true:
    yield(f)
    f *= 2

const custom_consume = |yield|
  while true:
    let val = yield()
    print(val)


fn main():
  # test_basic()
  test_concat2()
  # test_normal_concat()
  # test_concat2_concat2()
  # test_zip2()
  # test_interpose()
  # test_interleave()
  # test_interleave_to_iterator()
  # test_interleave_infinite()

  
fn test_basic():

  generator({|consume| 
    let elem1 = consume()
    print(elem1)
    let elem2 = consume()
    print(elem2)
    let elem3 = consume()
    print(elem3)
  }, {|yield|
    yield(1)
    yield(2)
    yield(3)
  })
  
fn test_concat2():


  const foo1 = |yield|
    let i = 0
    while i < 3:
      yield(i)
      i += 1

  const bar1 = |yield|
    let j = 0
    while j < 5:
      yield(j)
      j += 1
      
  const foo_then_bar = concat2(foo1, bar1)
  # let  num = 0
  for x in foo_then_bar:
    print(x)
    # num += x
  # assert(num == 249)
  
fn test_normal_concat():
  let num = 0
  for i in Range(0, 10):
    num += i
  for i in Range(1, 9):
    num += i * i
  assert(num == 249)

fn test_concat2_concat2():


  const foo_bar_bamp = concat2(concat2(foo, bar), bamp)
  let num = 0
  for y in foo_bar_bamp:
    num += y
  assert(num == 1545)

fn test_zip2():

  const zip_foo_bar = zip2(foo, bar)
  let num = 0
  for tup in zip_foo_bar:
    num += tup._1 * tup._2

  assert(num == 1092)

# fn test_zip_syntax():


#   zip_foo_bar :: %iter[
#     %ints ...,
#     foo[:] + bar[:] ...,
#     1, 2, 3
#   ]
  
# let   num = 0
#   for tup in zip_foo_bar:
#     num += tup._1 * tup._2

#   assert(num == 1092)

fn test_interpose():

  const interposed = interpose(foo, 1000)
  let num = 0
  for x2 in interposed:
    num += x2
  assert(num == 9045)
  
fn test_interleave():
  
  const interleaved = interleave(foo, bar)
  let num = 0
  for x3 in interleaved:
    num += x3
  assert(num == 240)
  
fn test_interleave_to_iterator():

  let thing = [10, 20, 30]
  const interleaved2 = interleave(to_iterator(thing), bar)
  let num = 0
  for x4 in interleaved2:
    num += x4
  assert(num == 74)

# fn test_interleave_infinite():

# let   thing = [10, 20, 30]
#   interleaved3 :: interleave_infinite(to_iterator(thing), bar)
# let   num = 0
#   for x5 in interleaved3:
#     num += x5
#   assert(num == 264)
