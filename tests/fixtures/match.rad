import compiler for Some, None, Option, assert, assert_compile_error

fn test_basic():
  let y = Some(1)

  let x = Some(1).match {
    Some(z) if z > 0: z + 2
    Some(z) if z == 0: 0
    None(): 100
  }
  assert(x == 3)

fn test_tuple():
  let x = (1, 2, true).match {
    (2, w, true): 23
    (z, 2, true): 1
    (z, w, true) if z > w: 2
    (z, w, y) if z < w: 3
    (z, w, y): 0
  }
  print(x)
  assert(x == 1)


fn test_nested():

  let y = (Some(1), Some(3))
  let x = y.match {
    (Some(z), None()) if z > 0: 3
    (Some(z), None()) if z > 0: z
    (Some(z), Some(w)) if z > 0: z + w
  }
  assert(x == 4)

fn test_nested_tuple():
  let y = ((1, 2), (3, (4, 5)))
  let x = y.match {
    ((1, 2), (3, (4, 5))): 23
    ((z, 2), (3, (4, 5))) if z > 0: 1
    ((z, w), (3, (4, 5))) if z > w: 2
    ((z, w), (y, (4, 5))) if z < w: 3
  }
  assert(x == 23)


fn test_fail():
  ((1, 2), (3, 3)).match {
    (a, b, c): 23
  }


fn test_nested_break():
  let y = Some(1)

  let x = y.match 'a {
    Some(x): 
      print("Some")
      if true:
        continue a
      1
    Some(x): 123
    None(): 0
  }
  assert(x == 123)
  
  # let x = y.match 'a {
    # is Some(z): z.match 'b {
  #     is % == 0: z + 2
  #     is % > 0: 0
  #   }
  #   is None(): 3
  # }
  # print(x)


fn main():
  test_basic()
  test_tuple()
  test_nested()
  test_nested_break()

  assert_compile_error!(test_fail, "Expected tuple with 2 fields got 3")

  