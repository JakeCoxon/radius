import compiler
import range for Range
import array for Array, array_create
import graphics for frame_ticks, copy_pixels

fn main():

  begin_app()

  const scale = 2
  const num_cells = 320 / scale

  let cells = array_create!int(num_cells)
  let next_cells = array_create!int(num_cells)

  cells[:] = 0 ...
  cells[num_cells / 2] = 1

  fill_rect(0, 0, 320, 240, 0)

  while window_open():

    copy_pixels(0, scale, 320, 240, 0, 0)

    for x in Range(1, num_cells - 1):
      next_cells[x] = calculate_state(
        cells[x - 1], cells[x], cells[x + 1])

    for x in Range(0, num_cells):
      let c = ifx next_cells[x] == 1: 0xffffffff else: 0
      fill_rect(scale * x, 240 - scale, scale, scale, c)

    let swap = cells
    cells = next_cells
    next_cells = swap


# https://mathworld.wolfram.com/ElementaryCellularAutomaton.html
const rule_num = 126

const bsl = compiler.operator_bitshift_left
const bsr = compiler.operator_bitshift_right
const band = compiler.operator_bitwise_and

fn calculate_state(a: int, b: int, c: int) -> int:
  let index = bsl(a, 2) + bsl(b, 1) + c
  band(bsr(rule_num, index), 1)
