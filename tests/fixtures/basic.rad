import compiler

type Foo @struct:
  x: int
  y: float


type Buffer @struct:
  size: int
  data: rawptr

  const __destructor = deinit_buffer
  const __move_init = move_init_buffer
  const __move_assign = move_assign_buffer
  const __copy = copy_buffer


fn buffer_alloc(buf: inout Buffer, size: int):
  buf.size = size + 0
  buf.data = malloc(size)


fn copy_buffer(dst: set Buffer, buf: Buffer):
  dst.size = buf.size + 0
  dst.data = malloc(buf.size)


fn move_init_buffer(dst: set Buffer, src: sink Buffer):
  dst.size = src.size
  dst.data = src.data
  src.data = rawptr(0)


fn move_assign_buffer(dst: inout Buffer, src: sink Buffer):
  deinit_buffer(dst)
  dst.size = src.size
  dst.data = src.data
  src.data = rawptr(0)


fn deinit_buffer(buf: sink Buffer):
  if buf.data != rawptr(0):
    free(buf.data)
    buf.data = rawptr(0)


type Array!(T) @struct:
  len: int
  data: Buffer

  const __set_subscript = set_array
  const __subscript = get_array
  const __copy = copy_array


fn init_array!(T)(arr: inout Array!T, len: int):
  arr.len = len + 0
  buffer_alloc(arr.data, len * (meta T.sizeof))


fn set_array!(T)(arr: inout Array!T, index: int, value: sink T) @inline:
  if arr.data.data == rawptr(0):
    init_array(arr, 10)
  compiler.unsafe_set_subscript(arr.data.data, index, value)


fn get_array!(T)(arr: Array!T, index: int) -> T @inline:
  compiler.unsafe_subscript!T(arr.data.data, index)


fn copy_array!(T)(dst: set Array!T, src: Array!T):
  dst.len = src.len + 0
  dst.data = compiler.copy(src.data)
  var i = 0
  while i < src.len:
    dst[i] = compiler.copy(src[i])
    i += 1

  # TODO: This is calling destructorFoo which doesn't seem right


fn bar(x: inout int):
  x += 1


fn baz(foo: inout Foo):
  foo.x += 1


fn test_array1():

  var buffer = Buffer(0, rawptr(0))
  var arr = Array!int(0, buffer)
  init_array(arr, 10)

  arr[0] = 10
  arr[1] = 20
  print(arr[0])


fn test_array2():

  var buffer = Buffer(0, rawptr(0))
  var arr = Array!Foo(0, buffer)
  init_array(arr, 10)

  arr[0] = Foo(3, 2.0)
  arr[1] = Foo(4, 3.0)

  arr[0].x += 1
  
  print(arr[0].x)

  var arr2 = compiler.copy(arr)


fn test_array3():

  var buffer = Buffer(0, rawptr(0))
  var arr = Array!(Array!Foo)(0, buffer)
  init_array(arr, 10)

  arr[0][0] = Foo(42, 2.0)
  print(arr[0][0].x)


fn main():

  test_array1()
  test_array2()
  test_array3()

  let zzz = 3
  let z: int = 2
  # let x: int = ifx 2 == 2: z else: 2
  let x = z + 232

  var foo = Foo(1, 2.0)
  foo.x += 1
  print(foo.x)

  bar(foo.x)
  print(foo.x)
  baz(foo)
  print(foo.x)

  while foo.x < 10:
    foo.x += 1

  print(foo.x)


  if !!!(2 == 2):
    print(21) 

  if 3 == 1 and 2 > 1:
    print(1)
