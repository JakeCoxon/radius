import compiler for assert

fn compose3(a, b, c) -> any:
  {|x| a(b(c(x)))}

fn compose2(a, b) -> any:
  {|x| a(b(x))}

fn transduce!(trx, reducer)(iterable) @inline:
  final_reducer :: trx(reducer)
  acc := final_reducer.a()
  for x in iterable:
    acc = final_reducer.c(acc, x)
  final_reducer.b(acc)

fn transduce_s!(trx, reducer, iterable)() -> any @inline:
  final_reducer :: trx(reducer)
  acc := final_reducer.a()
  for x in iterable:
    acc = final_reducer.c(acc, x)
  final_reducer.b(acc)

fn map(mapping) -> any:
  {|next| %{
    a = next.a,
    b = next.b,
    c = {|acc, x| next.c(acc, mapping(x))}
  } }

fn filter(predicate) -> any:
  {|next| %{
    a = next.a,
    b = next.b,
    c = {|acc, x| ifx predicate(x): next.c(acc, x) else: acc}
  } }

fn sum() -> any: 
  %{a = {|| 0},
    b = {|acc| acc},
    c = {|acc, x| acc + x} }

fn main():
  trx :: compose3(
    map {|x| x + 1},
    filter {|x| x < 4 },
    map {|x| x + 4}
  )

  list := [1, 2, 3, 4, 5, 6, 7]
  sum_result := transduce!(trx, sum())(list) # 6 + 7
  assert(sum_result == 13)
  
  sum_result2 := [1, 2, 3, 4, 5, 6, 7 | trx |> sum()] # 6 + 7
  assert(sum_result2 == 13)

  sum_result3 := [list... | trx |> sum()] # 6 + 7
  assert(sum_result3 == 13)
